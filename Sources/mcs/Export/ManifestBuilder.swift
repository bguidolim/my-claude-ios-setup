import Foundation

/// Converts discovered configuration artifacts into a formatted techpack.yaml
/// string using shorthand syntax with proper key ordering, comments, and quoting.
///
/// This is the core transformation: live config → manifest YAML text.
/// It handles sensitive env var → placeholder substitution and
/// generates corresponding `prompts` entries.
struct ManifestBuilder {

    struct Metadata {
        let identifier: String
        let displayName: String
        let description: String
        let version: String
        let author: String?
    }

    struct BuildResult {
        /// The fully rendered techpack.yaml content as a string.
        let manifestYAML: String
        let filesToCopy: [FileCopy]
        /// Serialized JSON data for config/settings.json, or nil if no extra settings.
        let settingsToWrite: Data?
        let templateFiles: [TemplateFile]
    }

    struct FileCopy {
        let source: URL
        let destinationDir: String
        let filename: String
    }

    struct TemplateFile {
        let sectionIdentifier: String
        let filename: String
        let content: String
    }

    typealias Config = ConfigurationDiscovery.DiscoveredConfiguration

    // MARK: - Build

    func build(
        from config: Config,
        metadata: Metadata,
        selectedMCPServers: Set<String>,
        selectedHookFiles: Set<String>,
        selectedSkillFiles: Set<String>,
        selectedCommandFiles: Set<String>,
        selectedPlugins: Set<String>,
        selectedSections: Set<String>,
        includeUserContent: Bool,
        includeGitignore: Bool,
        includeSettings: Bool
    ) -> BuildResult {
        var yaml = YAMLRenderer()
        var prompts: [PromptEntry] = []
        var filesToCopy: [FileCopy] = []
        var templateFiles: [TemplateFile] = []
        var settingsToWrite: Data?

        // ── Header ──────────────────────────────────────────────────────────
        // Schema reference: https://github.com/bguidolim/MyClaudeSetup
        yaml.comment("Generated by `mcs export` — review and customize before sharing.")
        yaml.comment("Schema reference: https://github.com/bguidolim/mcs/blob/main/docs/techpack-schema.md")
        yaml.comment("Guide: https://github.com/bguidolim/mcs/blob/main/docs/creating-tech-packs.md")
        yaml.blank()

        // ── Metadata (always first) ─────────────────────────────────────────
        yaml.keyValue("schemaVersion", 1)
        yaml.keyValue("identifier", metadata.identifier)
        yaml.keyValue("displayName", metadata.displayName, quoted: true)
        yaml.keyValue("description", metadata.description)
        yaml.keyValue("version", metadata.version, quoted: true)
        if let author = metadata.author {
            yaml.keyValue("author", author)
        }
        // yaml.keyValue("minMCSVersion", "2026.3.1", quoted: true)

        // ── Prompts ─────────────────────────────────────────────────────────
        // (deferred — populated during component building, written after)

        // ── Components ──────────────────────────────────────────────────────
        yaml.blank()
        yaml.sectionDivider("Components")

        yaml.line("components:")

        // MCP Servers
        let selectedServers = config.mcpServers.filter { selectedMCPServers.contains($0.name) }
        if !selectedServers.isEmpty {
            yaml.comment("  ── MCP Servers ─────────────────────────────────────────────────────────", indent: 2)
            for server in selectedServers {
                let serverPrompts = writeMCPServerComponent(server, to: &yaml)
                prompts.append(contentsOf: serverPrompts)
            }
        }

        // Hooks
        let selectedHooks = config.hookFiles.filter { selectedHookFiles.contains($0.filename) }
        if !selectedHooks.isEmpty {
            yaml.blank()
            yaml.comment("  ── Hooks ───────────────────────────────────────────────────────────────", indent: 2)
            for hook in selectedHooks {
                writeHookComponent(hook, to: &yaml)
                filesToCopy.append(FileCopy(
                    source: hook.absolutePath,
                    destinationDir: "hooks",
                    filename: hook.filename
                ))
            }
        }

        // Skills
        let selectedSkills = config.skillFiles.filter { selectedSkillFiles.contains($0.filename) }
        if !selectedSkills.isEmpty {
            yaml.blank()
            yaml.comment("  ── Skills ──────────────────────────────────────────────────────────────", indent: 2)
            for skill in selectedSkills {
                writeSkillComponent(skill, to: &yaml)
                filesToCopy.append(FileCopy(
                    source: skill.absolutePath,
                    destinationDir: "skills",
                    filename: skill.filename
                ))
            }
        }

        // Commands
        let selectedCmds = config.commandFiles.filter { selectedCommandFiles.contains($0.filename) }
        if !selectedCmds.isEmpty {
            yaml.blank()
            yaml.comment("  ── Commands ────────────────────────────────────────────────────────────", indent: 2)
            for cmd in selectedCmds {
                writeCommandComponent(cmd, to: &yaml)
                filesToCopy.append(FileCopy(
                    source: cmd.absolutePath,
                    destinationDir: "commands",
                    filename: cmd.filename
                ))
            }
        }

        // Plugins
        let selectedPluginList = config.plugins.filter { selectedPlugins.contains($0) }
        if !selectedPluginList.isEmpty {
            yaml.blank()
            yaml.comment("  ── Plugins ─────────────────────────────────────────────────────────────", indent: 2)
            for plugin in selectedPluginList {
                writePluginComponent(plugin, to: &yaml)
            }
        }

        // Configuration (settings + gitignore)
        var hasConfig = false
        if includeSettings, let data = config.remainingSettingsData {
            if !hasConfig {
                yaml.blank()
                yaml.comment("  ── Configuration ───────────────────────────────────────────────────────", indent: 2)
                hasConfig = true
            }
            writeSettingsComponent(to: &yaml)
            settingsToWrite = data
        }

        if includeGitignore, !config.gitignoreEntries.isEmpty {
            if !hasConfig {
                yaml.blank()
                yaml.comment("  ── Configuration ───────────────────────────────────────────────────────", indent: 2)
            }
            writeGitignoreComponent(config.gitignoreEntries, to: &yaml)
        }

        // ── Templates ───────────────────────────────────────────────────────
        var templateEntries: [(sectionID: String, contentFile: String)] = []

        for section in config.claudeSections where selectedSections.contains(section.sectionIdentifier) {
            let filename = sanitizeFilename(section.sectionIdentifier) + ".md"
            let shortID = shortIdentifier(section.sectionIdentifier, packID: metadata.identifier)
            templateEntries.append((sectionID: shortID, contentFile: "templates/\(filename)"))
            templateFiles.append(TemplateFile(
                sectionIdentifier: section.sectionIdentifier,
                filename: filename,
                content: section.content
            ))
        }

        if includeUserContent, let userContent = config.claudeUserContent {
            let filename = "custom.md"
            templateEntries.append((sectionID: "custom", contentFile: "templates/\(filename)"))
            templateFiles.append(TemplateFile(
                sectionIdentifier: "\(metadata.identifier).custom",
                filename: filename,
                content: userContent
            ))
        }

        if !templateEntries.isEmpty {
            yaml.blank()
            yaml.sectionDivider("Templates — CLAUDE.local.md sections")
            yaml.line("templates:")
            for entry in templateEntries {
                yaml.line("  - sectionIdentifier: \(entry.sectionID)")
                yaml.line("    contentFile: \(entry.contentFile)")
                // TODO: Add `placeholders:` if your template uses __PLACEHOLDER__ tokens
            }
        }

        // ── Prompts (write now that we've collected them) ───────────────────
        if !prompts.isEmpty {
            // Insert prompts section before components by rebuilding
            // Actually, we'll append at the end and note the recommended position
            yaml.blank()
            yaml.sectionDivider("Prompts — resolved interactively during `mcs sync`")
            yaml.line("prompts:")
            for prompt in prompts {
                yaml.line("  - key: \(prompt.key)")
                yaml.line("    type: \(prompt.type)")
                yaml.line("    label: \(yamlQuote(prompt.label))")
            }
        }

        // ── TODOs ───────────────────────────────────────────────────────────
        yaml.blank()
        yaml.sectionDivider("TODO — Review before sharing")
        yaml.comment("- [ ] Review component descriptions and add displayName where helpful")
        yaml.comment("- [ ] Add `dependencies:` between components if needed (e.g. MCP server depends on brew package)")
        yaml.comment("- [ ] Add `isRequired: true` to components that should always be installed")
        yaml.comment("- [ ] Add brew dependencies for MCP server runtimes (node, uv, python3)")
        yaml.comment("- [ ] Add `supplementaryDoctorChecks:` for health verification")
        yaml.comment("- [ ] Add `configureProject:` script if project-level setup is needed")
        yaml.comment("- [ ] Move `prompts:` section before `components:` for readability")
        yaml.comment("- [ ] Add `placeholders:` to templates that use __PLACEHOLDER__ tokens")

        return BuildResult(
            manifestYAML: yaml.output,
            filesToCopy: filesToCopy,
            settingsToWrite: settingsToWrite,
            templateFiles: templateFiles
        )
    }

    // MARK: - Component Writers

    struct PromptEntry {
        let key: String
        let type: String
        let label: String
    }

    private func writeMCPServerComponent(
        _ server: ConfigurationDiscovery.DiscoveredMCPServer,
        to yaml: inout YAMLRenderer
    ) -> [PromptEntry] {
        let id = "mcp-\(server.name)"
        var prompts: [PromptEntry] = []

        // Brew dependency hint
        if let command = server.command, needsBrewHint(command) {
            yaml.comment("  TODO: Consider adding a `brew: \(inferBrewPackage(command))` dependency component", indent: 2)
        }

        yaml.line("  - id: \(id)")
        yaml.line("    description: \(server.name) MCP server")

        if server.isHTTP {
            yaml.line("    mcp:")
            if let url = server.url {
                yaml.line("      url: \(url)")
            }
        } else {
            yaml.line("    mcp:")
            if let command = server.command {
                yaml.line("      command: \(command)")
            }
            if !server.args.isEmpty {
                yaml.line("      args:")
                for arg in server.args {
                    yaml.line("        - \(yamlQuote(arg))")
                }
            }
        }

        // Env vars — replace sensitive ones with placeholders
        if !server.env.isEmpty {
            let sensitiveNames = server.sensitiveEnvVarNames
            yaml.line("      env:")
            for key in server.env.keys.sorted() {
                let value = server.env[key]!
                if sensitiveNames.contains(key) {
                    let placeholder = "__\(key)__"
                    yaml.line("        \(key): \(yamlQuote(placeholder))")
                    prompts.append(PromptEntry(
                        key: key,
                        type: "input",
                        label: "Enter value for \(key) (used by \(server.name) MCP server)"
                    ))
                } else {
                    yaml.line("        \(key): \(yamlQuote(value))")
                }
            }
        }

        if server.scope != "local" {
            yaml.line("      scope: \(server.scope)")
        }

        yaml.blank()
        return prompts
    }

    private func writeHookComponent(_ hook: ConfigurationDiscovery.DiscoveredFile, to yaml: inout YAMLRenderer) {
        let id = "hook-\(sanitizeID(hook.filename))"
        yaml.line("  - id: \(id)")
        yaml.line("    description: Hook script for \(hook.hookEvent ?? "unknown event")")
        if let event = hook.hookEvent {
            yaml.line("    hookEvent: \(event)")
        } else {
            yaml.comment("    TODO: Add hookEvent (e.g. SessionStart, PreToolUse, Stop)", indent: 4)
        }
        yaml.line("    hook:")
        yaml.line("      source: hooks/\(hook.filename)")
        yaml.line("      destination: \(hook.filename)")
        yaml.blank()
    }

    private func writeSkillComponent(_ skill: ConfigurationDiscovery.DiscoveredFile, to yaml: inout YAMLRenderer) {
        let id = "skill-\(sanitizeID(skill.filename))"
        yaml.line("  - id: \(id)")
        yaml.line("    description: \(skill.filename) skill")
        yaml.line("    skill:")
        yaml.line("      source: skills/\(skill.filename)")
        yaml.line("      destination: \(skill.filename)")
        yaml.blank()
    }

    private func writeCommandComponent(_ cmd: ConfigurationDiscovery.DiscoveredFile, to yaml: inout YAMLRenderer) {
        let id = "cmd-\(sanitizeID(cmd.filename))"
        yaml.line("  - id: \(id)")
        yaml.line("    description: /\(cmd.filename.replacingOccurrences(of: ".md", with: "")) command")
        yaml.line("    command:")
        yaml.line("      source: commands/\(cmd.filename)")
        yaml.line("      destination: \(cmd.filename)")
        yaml.blank()
    }

    private func writePluginComponent(_ plugin: String, to yaml: inout YAMLRenderer) {
        let id = "plugin-\(sanitizeID(plugin))"
        yaml.line("  - id: \(id)")
        yaml.line("    description: \(plugin.split(separator: "@").first.map(String.init) ?? plugin) plugin")
        yaml.line("    plugin: \(yamlQuote(plugin))")
        yaml.blank()
    }

    private func writeSettingsComponent(to yaml: inout YAMLRenderer) {
        yaml.line("  - id: settings")
        yaml.line("    description: Additional settings (env vars, permissions, etc.)")
        yaml.line("    isRequired: true")
        yaml.line("    settingsFile: config/settings.json")
        yaml.blank()
    }

    private func writeGitignoreComponent(_ entries: [String], to yaml: inout YAMLRenderer) {
        yaml.line("  - id: gitignore")
        yaml.line("    description: Global gitignore entries")
        yaml.line("    isRequired: true")
        yaml.line("    gitignore:")
        for entry in entries {
            yaml.line("      - \(entry)")
        }
        yaml.blank()
    }

    // MARK: - Brew Dependency Hints

    private static let brewHintCommands: [String: String] = [
        "node": "node", "npx": "node", "npm": "node",
        "python3": "python3", "uvx": "uv", "uv": "uv", "pipx": "pipx",
    ]

    private func needsBrewHint(_ command: String) -> Bool {
        let basename = URL(fileURLWithPath: command).lastPathComponent
        return Self.brewHintCommands[basename] != nil
    }

    private func inferBrewPackage(_ command: String) -> String {
        let basename = URL(fileURLWithPath: command).lastPathComponent
        return Self.brewHintCommands[basename] ?? basename
    }

    // MARK: - Helpers

    private func sanitizeID(_ name: String) -> String {
        name.replacingOccurrences(of: ".", with: "-")
            .replacingOccurrences(of: "_", with: "-")
            .replacingOccurrences(of: " ", with: "-")
            .replacingOccurrences(of: "@", with: "-")
            .lowercased()
            .filter { $0.isLetter || $0.isNumber || $0 == "-" }
    }

    private func shortIdentifier(_ fullID: String, packID: String) -> String {
        let prefix = "\(packID)."
        if fullID.hasPrefix(prefix) {
            return String(fullID.dropFirst(prefix.count))
        }
        if let dotIndex = fullID.lastIndex(of: ".") {
            return String(fullID[fullID.index(after: dotIndex)...])
        }
        return fullID
    }

    private func sanitizeFilename(_ name: String) -> String {
        name.replacingOccurrences(of: ".", with: "-")
            .replacingOccurrences(of: " ", with: "-")
            .lowercased()
    }
}

// MARK: - YAML Quoting

/// Determines if a YAML string value needs quoting and returns the properly formatted value.
private func yamlQuote(_ value: String) -> String {
    // Always quote if it contains characters that could cause YAML parsing issues
    let needsQuoting = value.isEmpty
        || value.hasPrefix("@")
        || value.hasPrefix("-")
        || value.hasPrefix("*")
        || value.hasPrefix("&")
        || value.hasPrefix("{")
        || value.hasPrefix("[")
        || value.hasPrefix("!")
        || value.hasPrefix("%")
        || value.hasPrefix("__")
        || value.contains(": ")
        || value.contains("#")
        || value.contains("\"")
        || value.contains("'")
        || ["true", "false", "yes", "no", "null", "~"].contains(value.lowercased())

    if needsQuoting {
        // Use double quotes and escape internal double quotes
        let escaped = value.replacingOccurrences(of: "\\", with: "\\\\")
            .replacingOccurrences(of: "\"", with: "\\\"")
        return "\"\(escaped)\""
    }
    return value
}

// MARK: - YAML Renderer

/// Simple YAML text builder with support for comments, sections, and proper formatting.
struct YAMLRenderer {
    private var lines: [String] = []

    var output: String {
        lines.joined(separator: "\n") + "\n"
    }

    mutating func line(_ text: String) {
        lines.append(text)
    }

    mutating func blank() {
        lines.append("")
    }

    mutating func comment(_ text: String, indent: Int = 0) {
        let prefix = String(repeating: " ", count: indent)
        lines.append("\(prefix)# \(text)")
    }

    mutating func sectionDivider(_ title: String) {
        lines.append("# ---------------------------------------------------------------------------")
        lines.append("# \(title)")
        lines.append("# ---------------------------------------------------------------------------")
    }

    mutating func keyValue(_ key: String, _ value: Any, quoted: Bool = false) {
        if let str = value as? String {
            lines.append("\(key): \(quoted ? yamlQuote(str) : str)")
        } else {
            lines.append("\(key): \(value)")
        }
    }
}
