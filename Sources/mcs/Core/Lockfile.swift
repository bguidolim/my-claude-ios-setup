import Foundation
import Yams

/// Codable model for `mcs.lock.yaml` â€” pins exact pack versions for reproducible setups.
/// This file is committed to git so teammates get identical configurations.
struct Lockfile: Codable, Equatable, Sendable {
    let lockVersion: Int
    let generatedAt: String
    let mcsVersion: String
    var packs: [LockedPack]

    /// A single pack entry in the lockfile.
    struct LockedPack: Codable, Equatable, Sendable {
        let identifier: String
        let version: String
        let sourceURL: String
        let commitSHA: String
    }

    /// Create a lockfile from the current registry state and selected pack identifiers.
    static func generate(
        registryEntries: [PackRegistryFile.PackEntry],
        selectedPackIDs: Set<String>
    ) -> Lockfile {
        let locked = registryEntries
            .filter { selectedPackIDs.contains($0.identifier) }
            .map { entry in
                LockedPack(
                    identifier: entry.identifier,
                    version: entry.version,
                    sourceURL: entry.sourceURL,
                    commitSHA: entry.commitSHA
                )
            }
            .sorted { $0.identifier < $1.identifier }

        return Lockfile(
            lockVersion: 1,
            generatedAt: ISO8601DateFormatter().string(from: Date()),
            mcsVersion: MCSVersion.current,
            packs: locked
        )
    }

    // MARK: - Persistence

    static let filename = "mcs.lock.yaml"

    /// Load lockfile from a project directory. Returns nil if the file doesn't exist.
    static func load(projectRoot: URL) throws -> Lockfile? {
        let path = projectRoot.appendingPathComponent(filename)
        let fm = FileManager.default
        guard fm.fileExists(atPath: path.path) else { return nil }
        let content = try String(contentsOf: path, encoding: .utf8)
        if content.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
            return nil
        }
        return try YAMLDecoder().decode(Lockfile.self, from: content)
    }

    /// Write lockfile to a project directory.
    func save(projectRoot: URL) throws {
        let path = projectRoot.appendingPathComponent(Lockfile.filename)
        let header = "# Auto-generated by mcs sync. Do not edit manually.\n# Run 'mcs sync' to regenerate.\n"
        let yaml = try YAMLEncoder().encode(self)
        let content = header + yaml
        try content.write(to: path, atomically: true, encoding: .utf8)
    }

    // MARK: - Comparison

    /// Compare the lockfile against current registry entries.
    /// Returns mismatches where the current checkout differs from the locked SHA.
    func detectMismatches(
        registryEntries: [PackRegistryFile.PackEntry]
    ) -> [Mismatch] {
        var mismatches: [Mismatch] = []

        for locked in packs {
            if let entry = registryEntries.first(where: { $0.identifier == locked.identifier }) {
                if entry.commitSHA != locked.commitSHA {
                    mismatches.append(Mismatch(
                        identifier: locked.identifier,
                        lockedSHA: locked.commitSHA,
                        currentSHA: entry.commitSHA,
                        lockedVersion: locked.version,
                        currentVersion: entry.version
                    ))
                }
            } else {
                mismatches.append(Mismatch(
                    identifier: locked.identifier,
                    lockedSHA: locked.commitSHA,
                    currentSHA: nil,
                    lockedVersion: locked.version,
                    currentVersion: nil
                ))
            }
        }

        return mismatches
    }

    /// A mismatch between the lockfile and the current registry state.
    struct Mismatch: Equatable, Sendable {
        let identifier: String
        let lockedSHA: String
        let currentSHA: String?    // nil if pack not registered
        let lockedVersion: String
        let currentVersion: String?
    }
}
